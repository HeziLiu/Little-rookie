# Ch02

##计算机图形系统的构成

图形的输入、输出设备以及必要的交互手段

包含4个层次：应用程序，图形支撑软件，高级语言，操作系统

+ 硬件设备包括：交互设备；输入输出设备；存储设备
+ 输入
  + 定位（鼠标器、键盘、数字化仪、触摸屏）
  + 笔划（数字化仪）
  + 送值（键盘数字键）
  + 字符串（键盘数字字母键）
  + 拾取（定位设备）
  + 选择（鼠标器、数字化仪、键盘的功能键）
+ 输出
  + 软拷贝设备    显示器
  + 硬拷贝设备    打印机、绘图仪、摄像机

## 图形软件标准分类

+ 数据接口标准  CGM
+ 子程序接口标准  GKS  CGI  PHIGS

# Ch03

## DDA直线生成算法

+ 算法思想：从直线段的起点像素出发，依据直线的微分方程依次确定描述直线的各个像素点

```c
Procedure DDA(x1,x2,y1,y2)
      var k, i: integer; x, y, dx, dy: real;
      begin 
           k:=abs(x2-x1);
           if abs(y2-y1)>k then k:=abs(y2-y1); //求最大增量
           dx:=(x2-x1)/k; dy:=(y2-y1)/k;
            x:=x1; y:=y1;
           for i:=1 to k do 
            begin
               plot(round(x), round(y));  //下一个像素点坐标
               x:=x+dx; y:=y+dy;
            end
       end
```

## Bresenham算法

+ 算法思想：根据直线的斜率确定选择X或者Y方向作为计长方向，在此方向上每次递增一个单位步长（或者一个像素单位），另一个方向上是否同时产生一个单位增量由一个计算量很小的判别式来判断
+ 算法原理

![1530500824364](C:\Users\78914\AppData\Local\Temp\1530500824364.png)

```C++
Procedure Bresenhamline(xs,ys,xe,ye)
      int x, y, deltax, deltay, e;
      begin
           deltax:=xe-xs; deltay:=ye-ys;
           e:=-deltax; x:=xs; y:=ys;
           for(i:=0 to deltax) do
                begin  
                  plot(x, y);
                  if (e>=0) then
                       begin
                            y:=y+1; e:=e-2*deltax;
                       end 
                  x:=x+1; e:=e+2*deltay;
               end
      end
```

## 直线段的属性

线性、线宽、颜色

## 圆弧生成算法

###Bresenham算法

+ 算法思想：从一个起点出发，利用判别式选择下一个显示点。判别式的值通过简单计算获得，其符号用作判断
+ 算法原理：绘制$1/8$圆弧，其他部分可用7个对称点绘出 方程：$x^2+y^2=R^2$
+ 算法描述

```C++
Procedure arc(r: integer);
       var x,y,d: integer;
       begin
            x:=0; y:=r; d:=3-2*r;
           while x<y do {
               plot(x,y);
               if d<0 then d:=d+4*x+6                 //y不变 
                         else {d:=d+4*(x-y)+10;       //y减1
                                  y:=y-1};
               x:=x+1;
               }
            if(x=y) then plot(x,y);
        end                              

```

## 正负法（逐点比较法）

+ 算法思想：区分不同象限的圆弧，选定圆弧起点后，在输出圆弧的过程中，根据当前点的位置与理想圆弧的关系和所在象限，决定下一步的走向，每次只在一个方向（X或Y）走步取点，一步步地逼近产生应显示的圆弧
+ 算法描述

```C++
Procedure pnarc(r,xc,yc: integer);
         var x,y,f: integer;
         begin
              x:=xc; y:=yc+r; f:=0;
              while y>yc do {            //画1/4圆弧
                   plot(x,y);
                   if f>0 then { f:=f-2*(y-yc)+1;
                                        y:=y-1}       //向圆内走
                             else { f:=f+2*(x-xc)+1;
                                        x:=x+1}      //向圆外走
                    }
            if (y=yc) plot(x,y)
         end
```

## 多边形逼近法

+ 算法原理：当圆的内接多边形边数足够多时，该多边形可以和圆接近到任意程度，因此在允许的误差范围内，可用多边形代替显示圆
+ 显示多边形的边用Bresenham直线生成算法实现

## 规则曲线生成

平面曲线分为：规则曲线（函数曲线）和不规则曲线（自由曲线）

## 椭圆生成算法

+ 标准方程法

  椭圆的标准方程：$\frac{x^2}{a^2}+\frac{y^2}{b^2}=1$

  可以解得：$y=±\frac{b*\sqrt{a^2-x^2}}{a}$

  

+ 参数方程法

  椭圆的参数方程为：$x=a\cos{t}$  $y=b\cos{t}$

## 字符的生成算法

+ 矢量字符

  字模

+ 点阵字符

  用掩模（包含该字符的像素信息的一小块光栅）来定义字符，保存在字符发生器中

## 区域填充算法

+ 平面多边形的阴影线填充
  

+ 光栅图形的区域填充

  + 种子填充法

    + 漫水法

      ```c++
      Procedure flood-fill-4(x,y,old-color,new-color:integer)
      begin 
         if getpixel(framebuffer,x,y)=old-color
         then begin
                  setpixel(framebuffer,x,y,newcolor);
                  flood-fill-4(x,y+1,old-color,new-color);
                  flood-fill-4(x,y-1,old-color,new-color);
                  flood-fill-4(x+1,y,old-color,new-color);
                  flood-fill-4(x-1,y,old-color,new-color);
               end
      end
      ```

    + 边界填充算法

      ```c++
      Procedure flood-fill-4(x,y,boundary-color,new-color:integer)
      begin 
         if getpixel(framebuffer,x,y)<>boundary-color and 
             getpixel(framebuffer,x,y)<>new-color
         then begin
                  setpixel(framebuffer,x,y,newcolor);
                  flood-fill-4(x,y+1, boundary-color,new-color);
                  flood-fill-4(x,y-1, boundary-color,new-color);
                  flood-fill-4(x+1,y, boundary-color,new-color);
                  flood-fill-4(x-1,y, boundary-color,new-color);
               end
      end
      ```

    + 扫描线种子填充算法、

      + 边的分配表ET：记录对多边形的所有棱边（除水平边）,按下端点的纵坐标y的分类

      + 边的活化链表AEL：记录当前扫描线与棱边的交点序列

        ![1530513743181](C:\Users\78914\AppData\Local\Temp\1530513743181.png)

        ![1530514096763](C:\Users\78914\AppData\Local\Temp\1530514096763.png)

+ 图案填充

  1.定义图案

  2.填充区域

# Ch04

## 齐次坐标

平面上一点$(x,y)$可以用齐次坐标$(hx，hy,h)$表示$（h≠0）$

齐次坐标不是唯一的，把$h=1$的齐次坐标称为规格化齐次坐标

## 变换矩阵



## 投影变换

+ 平行投影

  + 正平行投影

    + 正投影（三视图）正视图（YZ平面），俯视图（XY）和侧视图（XZ）

    + 正轴测投影（按投影面与三个轴方向的夹角是否相等，进一步分为以下几种）

      把物体绕Y轴顺时针旋转φ，再绕X轴逆时针旋转θ角，使投影方向与Z轴重合，最后做Z方向的正投影

      + 正等测
      + 正二测
      + 正三测

  + 斜平行投影

    + 斜等测
    + 斜二测

+ 透视投影

  从视点出发，投影线是不平行的

  任何一束不平行于投影平面的平行线的透视投影将汇聚成一点，称为**灭点**。灭点可以看作是无限远处的一点在投影面上的投影。**灭点有无限多个**

  在坐标轴方向的灭点称为**主灭点**，主灭点数和投影平面切割坐标轴的数量相对应的。

  透视投影根据主灭点的个数分为：

  + 一点透视
  + 二点透视
  + 三点透视

## 用户域和窗口区

用户域：世界坐标wc

窗口区：w是wc的一个子域

屏幕域：dc是设备输出图形的最大区域

视图区：任何小于或等于屏幕域的区域

## 二维图形的裁剪

原理：在显示图形之前，组成图形的每一个基本元素都要经过裁剪

+ 点在区域内外的判断
+ 计算图形元素与区域边界的交点

### 二维线段的裁剪

+ 编码裁剪法

  ![1530517344670](C:\Users\78914\AppData\Local\Temp\1530517344670.png)

  ![1530517321296](C:\Users\78914\AppData\Local\Temp\1530517321296.png)

### 中点分割裁剪法

+ 算法思想：当一条线段既不能直接接收也不能直接舍弃，欲求其与区域的交点时，假设此交点在线段的中点，如果估计错误，则将直线分为两段，并对该两段再分别加以测试，一直进行下去，直到原来线段的一段被直接接受，而另一段被直接舍弃。

## 多边形的裁剪

逐边裁剪法

双边裁剪法

## 三维线段的裁剪



# Ch05

## 交互设备

+ 定位设备
+ 键盘设备
+ 取数设备
+ 选择设备
+ 其他输入设备

## 基本交互任务

+ 定位

+ 选择

+ 数量输入

+ 文本输入

+ 三维交互任务

  定位、选择，旋转

## 高级交互技术

+ 几何约束
  + 定位约束
  + 方向约束
+ 拖动
+ 橡皮筋技术
+ 图形变化
+ 引力场效果
+ 标尺和导向线
+ 坐标显示
+ 在三视图上作三位输入
+ 推移
+ 结构平面

## 输入过程基本处理模式

把从输入设备输入的信息和应用程序有机地结合好

+ 请求方式
+ 取样方式
+ 事件方式

# Ch06 曲线曲面的表示

## Bezier曲线

+ 凸包性

  曲线位于其特征多边形构成的凸包之中

+ 几何不变性

  几何特性不随一定的坐标系变换而变化。与坐标系选择无关

+ 交互能力

  改变曲线形状

+ 保凸性

  如果平面上的凸控制多边形能导致所生成的曲线为凸曲线，称这个生成曲线的方法具有保凸性

## Bezier曲面

凸包性，几何不变性，交互能力

## B样条曲线

+ 凸包性

+ 分段多项式
+ 连续性
+ 几何不变性
+ 保凸性
+ 局部调整性
+ 造型灵活性

## B样条曲面

+ 凸包性

+ 几何不变性

+ 局部调整性

+ 人机交互性

  

## Coons曲面

特点：插值，它构造满足给定边界条件的曲面



# Ch07 三维实体的造型

+ 曲面造型

  如何在计算机内描述物体的表面，对它的外部形状显示与控制

  + 规则曲面（代数曲面与参数曲面）
  + 拟合曲面（Bezier曲面、B样条曲面、Coons曲面）

+ 立（实）体造型

  如何在计算机内定义、表示一个三维物体，计算和分析物体的整体性质

## 边界表示法

用顶点、棱边、表面等物体的边界信息来表示物体。边界就是物体内部点与外部点的分界面

+ 几何信息
+ 拓扑信息

#### 欧拉运算

拓扑一致性用欧拉公式表示：

$v-e+f-r=2(s-h)$

r s h表示表面边界的内环数，不相连的物体个数以及物体上通孔数目

## 体素构造表示法

物体的CSG树表示

## 八叉树表示

1. 空间位置枚举法
2. 八叉树表示法

## 其他常用立体造型方法

+ 基本体例表示
+ 单元分解法
+ 推移法

# Ch08 消隐技术

消隐：找出并消除物体中不可见的部分

根据消隐空间的不同，消隐算法可分为：

+  物体控件的消隐算法（光线投射）

  物体空间指物体所在的空间，即规范化投影空间，逐面比较，决定每个面棱之间的遮挡关系

+ 图象空间的消隐算法（区域子分、深度缓存、扫描线）

  图象空间就是屏幕坐标空间，逐像素判断，决定哪个多边形在该像素可见

+ 物体空间和图象空间的消隐算法（画家算法）

  在物体空间中预先计算面的可见性优先级，再在图象空间中生成消隐图

## 画家算法

+ 先把屏幕置成背景色
+ 再把物体的各个面按其离视点的远近进行排序，排序结果存在一张深度优先级表中
+ 然后按照从远到近的顺序逐个绘制各个面，后显示的图形取代先显示的画面，相当于消除隐藏面

## 区域子分算法

算法思想：

针对光栅扫描式图象显示器上填色产生图形的。是一种分而治之的算法