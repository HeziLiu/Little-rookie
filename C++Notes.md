## struct,class,union三者区别

#### struct与class

+ struct的成员变量默认是public的；而class的成员变量默认是private的
+ struct保证成员按照声明顺序在内存中存储，class不能保证
+ 对于继承来说，

#### struct与class

+ 默认情况下，struct的成员变量是public的，而class的成员变量是private的
+ struct保证成员按照声明顺序在内存中存储，而class不能保证
+ 对于继承来说，class默认是private继承，struct默认是public继承

#### struct与union

* 一个union类型的变量，所有成员变量共享一块内存，该内存的大小由这些成员变量中长度最大的一个来决定，而struct中成员变量内存都是独立的。（对于union的一个成员赋值，其他成员会重写，而struct不会）
* union分配的内存是连续的，而struct**不能保证**分配的内存是连续的



## 引用已经定义过的全局变量

同一个文件中，直接引用

若不在一个文件

+ 直接引用头文件
+ 用``extern``关键字重新声明



## 全局变量可不可以定义在被多个.c文件包含的头文件中？

全局变量的作用域是整个源程序，可被声明多次，但是只能定义依次。

实际编程中很少在头文件中定义全局变量，因为多次引用可能重定义



## 对于一个频繁使用的短小函数，在C语言中应用什么实现，在C++中应用什么实现

C用宏定义，C++用inline



## main函数执行以前 ，会执行什么代码

全局对象的构造函数会在main函数之前执行，e.g. ``int a;``初始化为0



## main函数执行之后，会执行什么代码

使用``on_exit(fun)``注册的函数会在代码执行完毕后执行



## 类的成员函数重载、覆盖和隐藏的概念和区别

###概念

* 重载：在同一个作用域内，有几个同名的函数，但是参数列表的个数和类型不同
* 覆盖：指派生类函数覆盖基类函数，函数名、参数类型、返回值类型一摸一样。派生类的对象会调用子类中的覆盖版本，覆盖符类中的函数版本
* 隐藏：指派生类的函数屏蔽了与其同名的基类函数

###区别

+ 覆盖与重载
  + 函数是否处在不同的作用域，参数列表是否一样；基类函数是否有virtual关键字
+ 隐藏与覆盖
  + 派生类的函数与基类的函数同名，但是参数**不同**。此时不论有无virtual关键字，基类的函数将被隐藏
  + 派生类的函数与基类的函数同名，参数也**相同**，但是基类函数没有virtual关键字。此时，基类的函数被隐藏有virtual，就是覆盖

**注：**若子类覆盖父类的函数但是不加virtual，也能实现多态，由于virtual修饰符会被隐形继承，但是尽量加上？？



## static关键字

编译器为局部变量在栈上分配空间，但是函数执行结束时会释放掉。static可以解决函数执行完后变量值被释放的问题，static**变量存储在静态存储区**

#### 缺点

不安全，作用域是全局的

#### 优点

由于静态变量对所有对象所公有，节省内存，提高时间效率

#### 使用方式

``<类名>：：<静态成员名>``

#### 作用

+ 全局变量的定义：为该变量分配静态存储区。程序运行结束前不会被释放
+ 声明和定义静态成员函数：表明该函数为静态函数，只能在本文件中被调用
+ 定义静态局部变量：只被初始化一次，只在程序运行结束后才被释放。**区别是作用域的范围**



## const与#define的概念和优缺点

#### const

用于定义常量、修饰函数参数、修饰函数返回值，可以避免被修改，提高程序的健壮性

#### define

宏定义，在编译的时候会进行替换，可避免没有意义的数字或字符串，便于程序的阅读

#### 区别

+ const定义的数据有数据类型，而宏变量没有数据类型。编译器可以对const常量进行**类型检查**，而对宏定义只进行字符**替换**，没有类型安全检查，所以字符替换时可能出错。

  ```c++
  const int a;//a是一个常整型数
  
  int const a;//a是一个常整型数
  
  const int *a;//a是一个指向常整型数的指针
  
  int * const a;//a是一个指向整型数的常指针
  
  int const * a const;//a是一个指向常整型数的常指针
  ```


#### static关键字的作用

+ 函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被**分配一次**
+ 模块内的static全局变量可以被模块内所有函数访问，但不能被模块外其他函数访问
+ 模块内的static函数只可被这一模块内的其他函数调用，该函数的使用范围被限制在声明它的模块内
+ 在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝
+ 在类中的static成员函数属于整个类所拥有，该函数不接收this指针，因而只能访问类的static成员变量

#### const关键字的作用

+ 欲阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对其进行初始化，因为以后就没有机会再去改变它了
+ 对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const,或二者同时指定为const
+ 在一个函数声明中，const可以修饰形参，表明其是一个输入参数，在函数内部不能改变其值
+ 对于类的成员函数，若指定其为const类型，则表明其是一个长函数，不能修改类的成员变量
+ 对于类的成员函数，有时必须指定其返回值为const类型，以使得其返回值不为“左值”？？



##堆栈溢出的原因

没有回收垃圾资源

#### 栈溢出

越界访问导致，e.g.局部变量数组越界访问或者函数内局部变量使用过多，超出了OS为该进程分配的栈的大小

#### 堆溢出

由于堆是用户申请的，所以溢出的原因可能是程序员申请了资源但是忘记释放



## 刷新缓冲区方式

换行刷新缓冲区：``printf("\n");``程序结束刷新缓冲区：``return 0;``



## 类和对象

#### 类

用来描述一组具有相似属性的东西的对象的一种数据结构（🙃啥玩意？？？）类中有数据成员的声明和定义，有成员函数的实现代码。

#### 对象

类的实例化。计算机中想要使用类，只能进行实例化



## 介绍STL，详细说明STL如何实现Vector

STL是标准模板库，由**容器 算法 迭代器**组成

#### 优点

+ 可方便的对一堆数据进行排序（sort()）
+ 调试程序时更加安全和方便
+ stl是跨平台的，linux下也能使用

#### vector

vector实际上就是一个动态数组，会根据数据的增加，动态的增加数组空间

#### STL7种主要容器

vector,list,deque,map,multimap,set,multiset



## 变量的声明和定义

声明：告诉编译器我有某个类型的变量，不会为其分配内存

定义：会分配内存



## 简述#define #endif和#ifndef的作用

避免头文件被重复引用

```C++
#ifndef CH_H //意思是如果没有引用ch.h

#define CH_H //引用ch.h

#endif //否则不需要引用
```



## 引用与指针

+ 引用必须被初始化，指针不必
+ 引用初始化以后不能被改变，指针可以改变所指的对象
+ 不存在指向空值的引用，但是存在指向空值的指针



##C++继承机制

n类成员的访问控制方式

public：类本身、派生类和其它类均可访问；

protected：类本身和派生类均可访问，其它类不能访问；

private（默认）：类本身可访问，派生类和其它类不能访问。



## 函数模板与类模板

#### 函数模板

函数模板的实例化是由编译程序在处理函数调用时自动完成的

函数模板是模板的一种，可生成各种类型的函数实例：

```C++
template

Type min( Type a, Type b ){
return a < b ? a : b;
}
```

参数分 类型参数（具体的类型）和非类型（常量表达式）

#### 类模板

其实例化必须由程序员在程序中显式地指定



## system("pause")的作用

DOS命令，按任意键继续，与getchar()相似，区别在于前者属于系统命令，后者属于C++标准函数库



## 析构函数和虚函数的用法和作用

#### 析构函数

类成员函数，在类对象生命结束的时候由系统自动调用，释放在构造函数中分配的资源

+ 函数名称固定： ~类名（）
+ 无返回类型，没有参数
+ 不可重载，一般由系统自动调用

#### 虚函数

为了实现多态，含有**纯虚函数**的类称为**抽象类**，不能实例化对象，主要用作接口类



## new、delete；malloc、free关系

new——delete：C++的运算符

malloc——free:C++/C语言标准库函数 ，**注**：申请和释放的对象只能是内部数据类型



## delete与delete[]区别

+ delete只会调用依一次析构函数，delete[]会调用每一个成员的析构函数
+ delete——new/ delete[]——new[]



#继承优缺点

* 优点：可以方便地改变父类的实现，可实现多态，子类可继承符类的方法和属性
* 缺点：破坏封装性，子类和父类可能存在耦合，子类不能改变父类的接口



## C和C++有什么不同

+ C是面向过程的，更偏向逻辑设计，C++是面向对象的，提供了类，偏向类的设计
+ C适合要求代码体积小的，效率高的场合 e.g.嵌入式



## 析构函数的调用次序

派生类的析构——>基类的析构

定义一个对象时，基类的构造函数——>派生类的构造函数



## 野指针

指向一个已删除的对象或无意义地址的指针。

与空指针区别：野指针无法通过简单地判断是否为NULL避免，而只能通过养成良好的编程习惯来尽力避免

原因：

指针变量没有被初始化，或指针被free或delete之后，未置为NULL



## 常量指针和指针常量

常量指针：指向一个常量的指针（可防止对指针误操作而修改该常量）

指针常量：是一个常量，且是一个指针（指针常量不能修改指针所指向的地址，但指针常量的内容是可变的）



## sizeof

C语言的一种单目操作符，并不是函数。以**字节**的形式返回操作数的大小

+ 当操作数是指针时，sizeof依赖于系统的位数
+ 当操作数具有数组类型时，其结果是数组的总字节数
+ union类型操作数的sizeof是其**最大字节**成员的字节数
+ struct类型操作数的sizeof是这种类型对象的总字节数

sizeof和strlen()的区别：

+ sizeof是运算符，计算数据所占的内存控件 strlen()是一个函数，计算字符数组的字符数
+ sizeof可以用类型作参数，strlen()只能用char*作参数（必须以‘/0’结束）
+ 数组作sizeif的参数不退化，传递给strlen就退化为指针了
+ sizeof结果类型是size_t，类型定义为unsigned int，该类型保证能容纳实现建立的最大对象的字节大小



## 若NULL和0作为空指针常数是等价的，那到底该用哪一个？

``denfine NULL 0``

+ **什么是空指针常量？**

  0、0L、‘\0’、3-3、0*17以及(void *)0都是空指针常量

+ **什么是空指针？**

  若p是一个指针变量，则p = 0;、p = 0L;、p = '\0';、p = 3 - 3;、p = 0 * 17; 中的任何一种赋值操作之后，p都会称为一个空指针，由系统保证空指针不指向任何实际的对象或者函数

+ **什么是NULL**

  NULL是一个标准规定的宏定义，用来表示空指针常量 p=NULL;

+ **空指针指向了内存的什么地方？**

  一般取决于系统的实现，我们常见的空指针一般指向0地址，即空指针的内部用全0表示，空指针的**逻辑地址**一定是0，对于空指针的地址，操作系统是特殊处理的。并非空指针指向一个0地址的物理地址

+ **可以用memset函数来得到一个空指针吗？**

  不行，``memset(&p,0,sizeof(p));``和``p=0;``不是等价的，有的系统中存在着“非零空指针”

+ **可以定义自己的NULL的实现吗？兼容NULL的值可以是1 2 3等值吗？**

  不行，NULL是标准库中的一个符合上述条件的保留标识符，若包含了相应的标准头文件而引入了NULL的话，则在程序中重新定义NULL为不同的内容是非法的，其行为是未定义的

+ **malloc函数在分配内存失败时返回0还是NULL**

  在标准中明确规定了在其内存分配失败时返回的是空指针



## 若NULL定义成``define NULL ((char *)0)``难道不就可以向函数传入不加转换的NULL了吗

不行，有的机器不同类型数据的指针有不同的内部表达。若是字符指针的函数没有问题，但对于其他类型的指针参数仍然有问题，而合法的构造如``FILE *fp = NULL;``则会失败



## 使用非全零的值作为空指针内部表达的机器上，NULL是如何定义的？

与其他机器一样定义为0.



## 空指针

“未分配”或“尚未指向任何地方”的指针

区别于**未初始化**的指针。空指针可确保不指向任何对象或函数；而未初始化指针则可能指向**任何地方**



## 能否用void** 指针作为参数使函数按引用接受一般指针？

不可移植。C中没有一般的指针的指针类型。void*可以用作一般指针知识因为当它和其他类型相互赋值的时候，如果需要，它可以自动转换成其他类型



## 枚举和#define有什么不同

+ define是在**预编译**阶段进行简单替换，枚举常量则是在**编译**的时候确定其值
+ 一般在编译器里，可以调试枚举常量，但是不能调试宏常量
+ 枚举可以一次定义大量相关的常量，而define宏一次只能定义一个



## C++文件编译与执行的四个阶段

* 预处理阶段。根据文件中的预处理指令来修改源文件的内容。e.g. #include
  * 宏定义
  * 文件包含
  * 条件编译
* 编译阶段，将其翻译成等价的中间代码或汇编代码
* 汇编阶段，把汇编语言翻译成目标机器指令
* 链接



## 声明**struct x1 { . . . }; 和typedef struct { . . . } x2; 有什么不同？** 

第一种声明了一个“结构标签”；

第二种声明了一个“类型定义”。

主要区别：第一种方式定义结构体变量需要写“struct x1”来引用第一种，而第二种方式定义结构体变量**不需要使用struct关键字**



## 函数指针

指向函数的指针。

```c++
char * (*fun1)(char * p1,char * p2);//fun1 不是函数名，而是一个指针变量，它指向一个函数。这个函数有两个指针类型的参数，函数的返回值也是一个指针。
char * *fun2(char * p1,char * p2);//是个二级指针
char * fun3(char * p1,char * p2);//函数的返回值为char *类型
```



### #error预处理

#### 作用

编译程序时，只要遇到#error就会生成一个编译错误提示星系，并停止编译。其语法形式为：

``#error error-message``

**注：**宏串error-message不用双引号包围。遇到#error指令时，错误信息被显示，可能同时还显示编译程序作者预先定义的其他内容



## 变量a的定义

```c++
int a; //一个整型数

int *a; //一个指向整型数的指针

int **a; //一个指向指针的的指针，它指向的指针是指向一个整型数

int a[10]; //一个有10个整型数的数组

int *a[10]; //一个有10个指针的数组，该指针是指向一个整型数的

int (*a)[10]; //一个指向有10个整型数数组的指针

int (*a)(int); //一个指向函数的指针，该函数有一个整型参数并返回一个整型数

int (*a[10])(int); // 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数
```



## 内联函数与宏的区别

+ 内联函数在**编译**时展开，宏在**预编译**时展开
+ 在编译时内联函数可以直接被嵌入到目标代码中，而宏知识一个简单的文本替换
+ 内联函数可以完成诸如类型检测、语句是否正确等编译功能，宏就不具备这样的功能
+ inline函数是函数，宏不是函数



## iostream与iostream.h的区别

``#include<iostream.h>`` 非标准输入输出流

``#include<iostream>``     标准输入输出流

含有.h就是非标准的，C的标准库函数，无.h的就要用到命令空间，是C++的



## namespace的使用

由于标准库非常的庞大，人为选择的类的名称或函数名很有可能和标准库中的某个名字相同。为避免命名冲突，就把标准库中的一切都放在名字空间std中。C++标准程序库中所有的标识符都被定义于一个名为std的namespace中



## 多态的作用

+ 可隐藏实现的西街，使得代码模块化，方便扩展
+ 可实现接口重用



## C++纯虚函数，虚函数，虚函数的实现，什么是虚指针

#### 纯虚函数

是在基类中声明的虚函数，在基类中没有定义，但要求任何派生类都要定义自己的实现方法

#### 虚指针（虚函数指针）

是虚函数的实现细节，带有虚函数的每一个对象都有一个虚指针指向该类的虚函数表

#### 虚函数

虚函数是在基类中被声明为virtual，并在派生类中重新定义的成员函数，可实现成员函数的动态覆盖

+ 与**纯虚函数**的区别：纯虚函数子类必须实现，纯虚函数优点是可以实现多态性。

#### 抽象类

包含纯虚函数的类称为抽象类，由于抽象类中包含了没有定义的纯虚函数所以不能定义抽象类的对象

#### 多态性

+ 静态多态：函数重载和运算符重载
+ 动态多态：虚函数来实现

#### 虚函数与构造函数，析构函数，成员函数的关系

+ 为什么基类析构函数是虚函数？

  编译器总是根据类型来调用类成员函数。但是一个派生类的指针可以安全地转化为一个基类的指针。这样删除一个基类的指针的时候，C++不管这个指针指向一个基类对象还是一个派生类的对象，调用的都是基类的析构函数而不是派生类的。如果你依赖于派生类的析构函数的代码来释放资源，而没有重载析构函数，那么会有资源泄漏

+ 为什么构造函数不能为虚函数？

  虚函数采用一种**虚调用**的方法。虚调用是一种可以在只有部分信息的情况下工作的机制。若创建一个对象，则需要知道对象的准确类型，因此构造函数不能为虚函数。

+ 若虚函数是有效的，那为什么不把所有函数设为虚函数？

  不行。因为每个虚函数的对象都要维护一个虚函数表，因此在使用虚函数的时候都会产生一定的系统开销，这是没有必要的。



### 面向对象的三个基本特征

+ 封装

  将客观事物抽象成类，每个类对自身的数据和方法。使得代码模块化，目的：代码重用

+ 继承

  子类继承父类的方法和属性，继承可以扩展已存在的代码，目的：代码重用

+ 多态

  允许子类类型的指针赋值给父类类型的指针



### 什么是“&（引用）”，声明和使用引用要注意的问题

引用：某个目标变量的“别名”

注意事项：

+ 声明一个引用时，必须要初始化
+ 初始化后，该引用名不能再作为其他变量名的别名
+ 引用本身不占存储单元，系统不给引用分配存储单元
+ 返回引用时，在内存中不产生被返回值的副本
+ 不能返回局部变量的引用，主要原因为局部变量会在函数返回后被销毁



### 指针与引用

##### 区别

+ 引用在创建的同时必须初始化，保证引用的对象是有效的，所以不存在NULL引用，而指针在定义的时候不必初始化，所以指针则可以是NULL，可在定义后面的任何地方重新赋值
+ 引用一旦被初始化为指向一个对象，它就不能被改变为另一个对象的引用；而指针在任何时候都可以改变为指向另一个对象
+ 引用的创建和销毁并不会调用类的拷贝构造函数

#####为什么传引用比传指针安全？

因为不存在空引用，并且引用一旦被初始化为一个对象，它就不能被改变为另一个对象的引用，所以比指针安全。

##### 使用常量指针难道不行吗？

由于const指针仍然存在空指针，并且有可能产生野指针，所以还是不安全



### 参数传递的方式

传值，传指针或者引用



### 拷贝函数

深拷贝：拷贝了资源和指针

浅拷贝：知识拷贝了指针，使得两个指针指向同一份资源，可能造成对同一份析构两次，程序崩溃，浪费时间并且不安全。

临时对象开销比局部对象小些



### 构造函数

+ 只在建立对象的时候自动被调用一次
+ 必须是public的，否则无法生成对象
+ 只负责自己的类构造对象



### 面向对象如何实现数据隐藏

public,private,protected



### char * ,float *,以及函数指针三种类型的变量哪个占用的内存最大

所有指针变量占用内存单元的数量都是相同的



### C++是不是类型安全的

不是，两个同类型的指针之间可以强制转换



### 模板和宏

标准库大量采用了模板技术 e.g.容器

模板：是一个蓝图，它本身不是类或函数。编译器用模板产生指定的类或函数的特定类型版本。模板的形参分为类型形参（表示类型的形参）和非类型形参



### 空指针与悬垂指针

空指针：指被赋值为NULL的指针

悬垂指针：delete指向动态分配对象的指针将会产生悬垂指针

+ 空指针可以被多次delete,而悬垂指针再次删除时程序会变得非常不稳定
+ 使用空指针和悬垂指针都是非法的，而且有可能造成程序崩溃，若指针是空指针，尽管同样是崩溃，但和悬垂指针相比是一种**可预料**的崩溃

```C++
int* a[4];//指针数组，用于存储指针的数组
*a[i];	  //元素表示

int(*a)[4];//数组指针，指向数组的指针
(*a)[i]	  //元素表示

int *f(x,y);//指针函数：函数返回类型是某一类型的指针
int (*f)(int x)//函数指针：是指向函数的指针变量，即本质是一个指针变量
```



### 智能指针

当类中有指针成员时，一般有两种方式来管理指针成员

+ 每个类对象都保留一份指针指向的对象的拷贝
+ 使用智能指针，从而实现指针指向的对象的共享。实质是使用计数器与对象相关联，这样做可以保证对象正确地删除，避免悬垂指针



### C++空类默认有哪些成员函数

默认构造函数 析构函数 复制构造函数 赋值函数



### 哪一种成员变量可以在一个类的实例之间共享

static静态成员变量



### 三种继承特点

+ 公有继承：派生类对象可以访问基类中的公有成员，派生类的成员函数可以访问基类中的公有和受保护成员；公有继承时基类受保护的成员，可以通过派生类对象访问但不能修改
+ 私有继承：基类的成员只能被**直接派生类**的成员访问，无法再往下继承
+ 受保护继承：同私有继承



### 只能用构造函数初始化列表而不能用赋值初始化

const成员，引用成员



### 内部连接和外部连接

##### 编译单元

当编译cpp文件时，预处理器首先递归包含头文件，形成一个编译单元。该编译单元会被编译成为一个与cpp文件名同名的目标文件（.o或.obj）连接程序把不同编译单元中产生的符号联系起来，构成一个可执行程序。

##### 内部连接

若一个名称对于它的编译单元来说局部的，并且在连接时不会与其他编译单元中的同样的名称相冲突，那么这个名称有内部连接：

+ 所有的声明
+ 名字空间（包括全局名字空间）中的静态自由函数、静态友元函数、静态变量的定义
+ enum定义
+ inline函数定义（自由函数和非自由函数）
+ 类的定义
+ 名字空间中const常量定义
+ union的定义

##### 外部连接

在一个多文件程序中，如果一个名称在连接时可以和其他编译单元交互，那么这个名称就有外部链接

+ 类非inline函数总有外部连接。（类成员函数和类静态成员函数）
+ 类静态成员变量总有外部连接
+ 名字空间（包括全局名字空间）中非静态自由函数、非静态友元函数及非静态变量



## 变量

##### 全局变量

在整个工程文件中都有效，若没有手工初始化，则编译器将其初始化为0

##### 静态全局变量

只在定义它的文件内有效，初始化同全局变量，定义存储类型为静态型的外部变量，作用域是从定义点到程序结束

##### 局部变量

在定义它的函数内有效，这个函数返回后会失效，如未初始化，值不可知

##### 静态局部变量

只在定义它的函数内有效，只是程序仅分配一次内存，函数返回后，该变量不会消失，直到程序运行结束才释放，初始化同全局变量

##### 静态型变量

存放在内存的数据区中，在程序开始运行前就为其分配了固定的字节，在程序运行中被分配的字节大小是不改变的，只有程序运行结束后，才释放占用的内存



## 应用程序在运行时的内存包括代码区和数据区，数据区又包括哪些

对进程的内存空间而言，逻辑上分为：代码区，静态数据区和动态数据区

+ 动态数据区：一般为“堆栈”。栈是一种线性结构，堆是一种链式结构。进程的每个线程都有私有的“栈“。存放本地变量，程序通过堆栈的基地址和偏移地址来访问
+ 静态数据区：存放全局变量和静态变量



## 异常框架

+ throw表达式：错误检测部分使用这种表达式来说明遇到了不可处理的错误
+ try块：错误处理部分使用它来处理异常

