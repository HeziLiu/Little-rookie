## struct,class,union三者区别

#### struct与class

+ struct的成员变量默认是public的；而class的成员变量默认是private的
+ struct保证成员按照声明顺序在内存中存储，class不能保证
+ 对于继承来说，

#### struct与class

+ 默认情况下，struct的成员变量是public的，而class的成员变量是private的
+ struct保证成员按照声明顺序在内存中存储，而class不能保证
+ 对于继承来说，class默认是private继承，struct默认是public继承

#### struct与union

* 一个union类型的变量，所有成员变量共享一块内存，该内存的大小由这些成员变量中长度最大的一个来决定，而struct中成员变量内存都是独立的。（对于union的一个成员赋值，其他成员会重写，而struct不会）
* union分配的内存是连续的，而struct**不能保证**分配的内存是连续的



## 引用已经定义过的全局变量

同一个文件中，直接引用

若不在一个文件

+ 直接引用头文件
+ 用``extern``关键字重新声明



## 全局变量可不可以定义在被多个.c文件包含的头文件中？

全局变量的作用域是整个源程序，可被声明多次，但是只能定义依次。

实际编程中很少在头文件中定义全局变量，因为多次引用可能重定义



## 对于一个频繁使用的短小函数，在C语言中应用什么实现，在C++中应用什么实现

C用宏定义，C++用inline



## main函数执行以前 ，会执行什么代码

全局对象的构造函数会在main函数之前执行，e.g. ``int a;``初始化为0



## main函数执行之后，会执行什么代码

使用``on_exit(fun)``注册的函数会在代码执行完毕后执行



## 类的成员函数重载、覆盖和隐藏的概念和区别

###概念

* 重载：在同一个作用域内，有几个同名的函数，但是参数列表的个数和类型不同
* 覆盖：指派生类函数覆盖基类函数，函数名、参数类型、返回值类型一摸一样。派生类的对象会调用子类中的覆盖版本，覆盖符类中的函数版本
* 隐藏：指派生类的函数屏蔽了与其同名的基类函数

###区别

+ 覆盖与重载
  + 函数是否处在不同的作用域，参数列表是否一样；基类函数是否有virtual关键字
+ 隐藏与覆盖
  + 派生类的函数与基类的函数同名，但是参数**不同**。此时不论有无virtual关键字，基类的函数将被隐藏
  + 派生类的函数与基类的函数同名，参数也**相同**，但是基类函数没有virtual关键字。此时，基类的函数被隐藏有virtual，就是覆盖

**注：**若子类覆盖父类的函数但是不加virtual，也能实现多态，由于virtual修饰符会被隐形继承，但是尽量加上？？



## static关键字

编译器为局部变量在栈上分配空间，但是函数执行结束时会释放掉。static可以解决函数执行完后变量值被释放的问题，static**变量存储在静态存储区**

#### 缺点

不安全，作用域是全局的

#### 优点

由于静态变量对所有对象所公有，节省内存，提高时间效率

#### 使用方式

``<类名>：：<静态成员名>``

#### 作用

+ 全局变量的定义：为该变量分配静态存储区。程序运行结束前不会被释放
+ 声明和定义静态成员函数：表明该函数为静态函数，只能在本文件中被调用
+ 定义静态局部变量：只被初始化一次，只在程序运行结束后才被释放。**区别是作用域的范围**



## const与#define的概念和优缺点

#### const

用于定义常量、修饰函数参数、修饰函数返回值，可以避免被修改，提高程序的健壮性

#### define

宏定义，在编译的时候会进行替换，可避免没有意义的数字或字符串，便于程序的阅读

#### 区别

+ const定义的数据有数据类型，而宏变量没有数据类型。编译器可以对const常量进行**类型检查**，而对宏定义只进行字符**替换**，没有类型安全检查，所以字符替换时可能出错。

  ```c++
  const int a;//a是一个常整型数
  
  int const a;//a是一个常整型数
  
  const int *a;//a是一个指向常整型数的指针
  
  int * const a;//a是一个指向整型数的常指针
  
  int const * a const;//a是一个指向常整型数的常指针
  ```


#### static关键字的作用

+ 函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被**分配一次**
+ 模块内的static全局变量可以被模块内所有函数访问，但不能被模块外其他函数访问
+ 模块内的static函数只可被这一模块内的其他函数调用，该函数的使用范围被限制在声明它的模块内
+ 在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝
+ 在类中的static成员函数属于整个类所拥有，该函数不接收this指针，因而只能访问类的static成员变量

#### const关键字的作用

+ 欲阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对其进行初始化，因为以后就没有机会再去改变它了
+ 对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const,或二者同时指定为const
+ 在一个函数声明中，const可以修饰形参，表明其是一个输入参数，在函数内部不能改变其值
+ 对于类的成员函数，若指定其为const类型，则表明其是一个长函数，不能修改类的成员变量
+ 对于类的成员函数，有时必须指定其返回值为const类型，以使得其返回值不为“左值”？？



##堆栈溢出的原因

没有回收垃圾资源

#### 栈溢出

越界访问导致，e.g.局部变量数组越界访问或者函数内局部变量使用过多，超出了OS为该进程分配的栈的大小

#### 堆溢出

由于堆是用户申请的，所以溢出的原因可能是程序员申请了资源但是忘记释放



## 刷新缓冲区方式

换行刷新缓冲区：``printf("\n");``程序结束刷新缓冲区：``return 0;``



## 类和对象

#### 类

用来描述一组具有相似属性的东西的对象的一种数据结构（🙃啥玩意？？？）类中有数据成员的声明和定义，有成员函数的实现代码。

#### 对象

类的实例化。计算机中想要使用类，只能进行实例化



## 介绍STL，详细说明STL如何实现Vector

STL是标准模板库，由**容器 算法 迭代器**组成

#### 优点

+ 可方便的对一堆数据进行排序（sort()）
+ 调试程序时更加安全和方便
+ stl是跨平台的，linux下也能使用

#### vector

vector实际上就是一个动态数组，会根据数据的增加，动态的增加数组空间

#### STL7种主要容器

vector,list,deque,map,multimap,set,multiset



## 变量的声明和定义

声明：告诉编译器我有某个类型的变量，不会为其分配内存

定义：会分配内存



## 简述#define #endif和#ifndef的作用

避免头文件被重复引用

```C++
#ifndef CH_H //意思是如果没有引用ch.h

#define CH_H //引用ch.h

#endif //否则不需要引用
```



## 引用与指针

+ 引用必须被初始化，指针不必
+ 引用初始化以后不能被改变，指针可以改变所指的对象
+ 不存在指向空值的引用，但是存在指向空值的指针



##C++继承机制

n类成员的访问控制方式

public：类本身、派生类和其它类均可访问；

protected：类本身和派生类均可访问，其它类不能访问；

private（默认）：类本身可访问，派生类和其它类不能访问。



## 函数模板与类模板

#### 函数模板

函数模板的实例化是由编译程序在处理函数调用时自动完成的

函数模板是模板的一种，可生成各种类型的函数实例：

```C++
template

Type min( Type a, Type b ){
return a < b ? a : b;
}
```

参数分 类型参数（具体的类型）和非类型（常量表达式）

#### 类模板

其实例化必须由程序员在程序中显式地指定



## system("pause")的作用

DOS命令，按任意键继续，与getchar()相似，区别在于前者属于系统命令，后者属于C++标准函数库



## 析构函数和虚函数的用法和作用

#### 析构函数

类成员函数，在类对象生命结束的时候由系统自动调用，释放在构造函数中分配的资源

+ 函数名称固定： ~类名（）
+ 无返回类型，没有参数
+ 不可重载，一般由系统自动调用

#### 虚函数

为了实现多态，含有**纯虚函数**的类称为**抽象类**，不能实例化对象，主要用作接口类



## new、delete；malloc、free关系

new——delete：C++的运算符

malloc——free:C++/C语言标准库函数 ，**注**：申请和释放的对象只能是内部数据类型



## delete与delete[]区别

+ delete只会调用依一次析构函数，delete[]会调用每一个成员的析构函数
+ delete——new/ delete[]——new[]



#继承优缺点

* 优点：可以方便地改变父类的实现，可实现多态，子类可继承符类的方法和属性
* 缺点：破坏封装性，子类和父类可能存在耦合，子类不能改变父类的接口



## C和C++有什么不同

+ C是面向过程的，更偏向逻辑设计，C++是面向对象的，提供了类，偏向类的设计
+ C适合要求代码体积小的，效率高的场合 e.g.嵌入式



## 析构函数的调用次序

派生类的析构——>基类的析构

定义一个对象时，基类的构造函数——>派生类的构造函数



## 野指针

指向一个已删除的对象或无意义地址的指针。

与空指针区别：野指针无法通过简单地判断是否为NULL避免，而只能通过养成良好的编程习惯来尽力避免

原因：

指针变量没有被初始化，或指针被free或delete之后，未置为NULL



## 常量指针和指针常量

常量指针：指向一个常量的指针（可防止对指针误操作而修改该常量）

指针常量：是一个常量，且是一个指针（指针常量不能修改指针所指向的地址，但指针常量的内容是可变的）



## sizeof

C语言的一种单目操作符，并不是函数。以**字节**的形式返回操作数的大小

+ 当操作数是指针时，sizeof依赖于系统的位数
+ 当操作数具有数组类型时，其结果是数组的总字节数
+ union类型操作数的sizeof是其**最大字节**成员的字节数
+ struct类型操作数的sizeof是这种类型对象的总字节数

sizeof和strlen()的区别：

+ sizeof是运算符，计算数据所占的内存控件 strlen()是一个函数，计算字符数组的字符数
+ sizeof可以用类型作参数，strlen()只能用char*作参数（必须以‘/0’结束）
+ 数组作sizeif的参数不退化，传递给strlen就退化为指针了
+ sizeof结果类型是size_t，类型定义为unsigned int，该类型保证能容纳实现建立的最大对象的字节大小



## 若NULL和0作为空指针常数是等价的，那到底该用哪一个？

``denfine NULL 0``

+ **什么是空指针常量？**

  0、0L、‘\0’、3-3、0*17以及(void *)0都是空指针常量

+ **什么是空指针？**

  若p是一个指针变量，则p = 0;、p = 0L;、p = '\0';、p = 3 - 3;、p = 0 * 17; 中的任何一种赋值操作之后，p都会称为一个空指针，由系统保证空指针不指向任何实际的对象或者函数

+ **什么是NULL**

  NULL是一个标准规定的宏定义，用来表示空指针常量 p=NULL;

+ **空指针指向了内存的什么地方？**

  一般取决于系统的实现，我们常见的空指针一般指向0地址，即空指针的内部用全0表示，空指针的**逻辑地址**一定是0，对于空指针的地址，操作系统是特殊处理的。并非空指针指向一个0地址的物理地址

+ **可以用memset函数来得到一个空指针吗？**

  不行，``memset(&p,0,sizeof(p));``和``p=0;``不是等价的，有的系统中存在着“非零空指针”

+ **可以定义自己的NULL的实现吗？兼容NULL的值可以是1 2 3等值吗？**

  不行，NULL是标准库中的一个符合上述条件的保留标识符，若包含了相应的标准头文件而引入了NULL的话，则在程序中重新定义NULL为不同的内容是非法的，其行为是未定义的

+ **malloc函数在分配内存失败时返回0还是NULL**

  在标准中明确规定了在其内存分配失败时返回的是空指针



## 若NULL定义成``define NULL ((char *)0)``难道不就可以向函数传入不加转换的NULL了吗

不行，有的机器不同类型数据的指针有不同的内部表达。若是字符指针的函数没有问题，但对于其他类型的指针参数仍然有问题，而合法的构造如``FILE *fp = NULL;``则会失败



## 使用非全零的值作为空指针内部表达的机器上，NULL是如何定义的？

与其他机器一样定义为0.



## 空指针

“未分配”或“尚未指向任何地方”的指针

区别于**未初始化**的指针。空指针可确保不指向任何对象或函数；而未初始化指针则可能指向**任何地方**



## 能否用void** 指针作为参数使函数按引用接受一般指针？

不可移植。C中没有一般的指针的指针类型。void*可以用作一般指针知识因为当它和其他类型相互赋值的时候，如果需要，它可以自动转换成其他类型



## 枚举和#define有什么不同

+ define是在**预编译**阶段进行简单替换，枚举常量则是在**编译**的时候确定其值
+ 一般在编译器里，可以调试枚举常量，但是不能调试宏常量
+ 枚举可以一次定义大量相关的常量，而define宏一次只能定义一个



## C++文件编译与执行的四个阶段

* 预处理阶段。根据文件中的预处理指令来修改源文件的内容。e.g. #include
  * 宏定义
  * 文件包含
  * 条件编译
* 编译阶段，将其翻译成等价的中间代码或汇编代码
* 汇编阶段，把汇编语言翻译成目标机器指令
* 链接



## 声明**struct x1 { . . . }; 和typedef struct { . . . } x2; 有什么不同？** 

第一种声明了一个“结构标签”；

第二种声明了一个“类型定义”。

主要区别：第一种方式定义结构体变量需要写“struct x1”来引用第一种，而第二种方式定义结构体变量**不需要使用struct关键字**



## 函数指针

指向函数的指针。

```c++
char * (*fun1)(char * p1,char * p2);//fun1 不是函数名，而是一个指针变量，它指向一个函数。这个函数有两个指针类型的参数，函数的返回值也是一个指针。
char * *fun2(char * p1,char * p2);//是个二级指针
char * fun3(char * p1,char * p2);//函数的返回值为char *类型
```



### #error预处理

#### 作用

编译程序时，只要遇到#error就会生成一个编译错误提示星系，并停止编译。其语法形式为：

``#error error-message``

**注：**宏串error-message不用双引号包围。遇到#error指令时，错误信息被显示，可能同时还显示编译程序作者预先定义的其他内容



## 变量a的定义

```c++
int a; //一个整型数

int *a; //一个指向整型数的指针

int **a; //一个指向指针的的指针，它指向的指针是指向一个整型数

int a[10]; //一个有10个整型数的数组

int *a[10]; //一个有10个指针的数组，该指针是指向一个整型数的

int (*a)[10]; //一个指向有10个整型数数组的指针

int (*a)(int); //一个指向函数的指针，该函数有一个整型参数并返回一个整型数

int (*a[10])(int); // 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数
```



## 内联函数与宏的区别

+ 内联函数在**编译**时展开，宏在**预编译**时展开
+ 在编译时内联函数可以直接被嵌入到目标代码中，而宏知识一个简单的文本替换
+ 内联函数可以完成诸如类型检测、语句是否正确等编译功能，宏就不具备这样的功能
+ inline函数是函数，宏不是函数



## iostream与iostream.h的区别

``#include<iostream.h>`` 非标准输入输出流

``#include<iostream>``     标准输入输出流

含有.h就是非标准的，C的标准库函数，无.h的就要用到命令空间，是C++的



## namespace的使用

由于标准库非常的庞大，人为选择的类的名称或函数名很有可能和标准库中的某个名字相同。为避免命名冲突，就把标准库中的一切都放在名字空间std中。C++标准程序库中所有的标识符都被定义于一个名为std的namespace中



## 多态的作用

+ 可隐藏实现的西街，使得代码模块化，方便扩展
+ 可实现接口重用



## C++纯虚函数，虚函数，虚函数的实现，什么是虚指针

#### 纯虚函数

是在基类中声明的虚函数，在基类中没有定义，但要求任何派生类都要定义自己的实现方法

#### 虚指针（虚函数指针）

是虚函数的实现细节

xu'h

